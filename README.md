# Рапределенный вычислитель(версия 2)


## Содержание

- [Введение](#intro)
- [Формулировка задачи](#goals)
- [Замечания к текущей версии](#remarks)
- [Общее описание](#solution-discriber)
    - [Схема взаимодействия компонент системы](#solution-arch)
- [Диспетчер](#dispatcher)
    - [Настройки Диспетчера](#dispatcher-settings)
    - [Запуск Диспетчера](#dispatcher-start)
    - [Запрос регистрации пользователя](#dispatcher-query-reguser)
    - [Запрос аутентификации пользователя](#dispatcher-query-auth)
    - [Запрос на вычисление выражений](#dispatcher-query-post)
    - [Запрос результатов вычислений](#dispatcher-query-get)
- [Хранилище](#storage)
     - [Настройка Хранилища](#storage-start)
- [Менеджер](#manager)
    - [Настройки Менеджера](#manager-settings)
    - [Запуск Менеджера](#manager-start)
    - [Взаимодействие с Демонами(вычислителями)](#manager-daemon)
    - [HTTP-интерфейс](#manager-frontend)
- [Демон](#daemon) 
    - [Настройки Демона](#daemon-settings)
    - [Вычисление выражений](#daemon-calc)
    - [Запуск Демона](#daemon-start)
    - [Взаимодействие с Менеджером](#daemon-manager)
    - [HTTP-интерфейс](#daemon-frontend)
- [Фронтальная часть(Frontend)](#frontend)
- [Подготовка и запуск проекта](#prepare_and_start)
- [Демо](#demo)





<a name="intro"><h2>Введение</h2></a>

 Работа выполнена в рамках заключительной части учебного курса 'Основы программирования на Golang' от Яндекс Лицея в 2024 году.


<a name="goals"><h3>Формулировка задачи</h3></a>

Общая формулировка, составленная на основе требований заданий: 
- Разработать программную систему, позволяющую выполнять распределенные вычисления простых алгебраических выражений - Распределенный вычислитель.
- Система должна включать в себя фронтальную(Frontend) и серверную(Backend) части.
- Система должна быть устойчива к выключениям основных компонент, т.е. должны быть реализованы механики, позволяющие продолжить вычисления без потерь результатов.  
- Система должна обеспечивать некоторый контроль и управление за ходом вычислений. Например, должна быть возможность задавать время вычисления отдельных операций, количество вычислителей, количество параллельных "потоков" вычислений и прочее.
- Серверные(Backend) компоненты должны взаимодействовать по протоколу gRPC, при этом, поскольку пользователи системы работают из Интернет браузера, то компоненты должны так же иметь и HTTP-интерфейсы.
- Необходимо реализовать основные механики регистрации и аутентификации пользователей на основе JWT. Обеспечить возможность отправки в систему выражений на вычисление только для успешно аутентифицированных пользователей. 

*Исходные требования - см. в заданиях в версиям(ниже)*


### Задание к версии 1
- [Скриншот задания №1](docs/the_formulation_of_the_task/zadacha_screen1.jpg)
- [Скриншот задания №2](docs/the_formulation_of_the_task/zadacha_screen2.jpg)
- [Перечень требований](docs/the_formulation_of_the_task/requirements1.txt)


### Задание к версии 2 (текущий дистрибутив)
- [Скриншот задания №1](docs/the_formulation_of_the_task/zadacha2_screen1.jpg)
- [Скриншот задания №2](docs/the_formulation_of_the_task/zadacha2_screen2.jpg)
- [Текст задания](docs/the_formulation_of_the_task/requirements2.txt)



<a name="remarks"><h3>Замечания к текущей версии</h3></a>

 - Вцелом структура компонент вычислителя осталась прежней: Диспетчер, Менеджер, Демон, Хранилище и фронтальная часть(HTML-страница с js-кодом).
 - Добавлена возможность выполнения вычислений на произвольном числе Демонов. Возможные ограничения по количеству используемых Демонов диктуются только количеством свободных портов, доступными процессорной и сетевой мощностью.
 - Менеджеру добавлен функционал равномерного распределения вычислительных задач по Демонм. Алгоритм балансировки реализует случайный выбор Демона-исполнителя вычисления. Менеджер ведет периодический учёт активных Демонов. При длительной неактивности Демона, Менеджер переназначит продолжение вычисления другому Демону(при наличии такового). При кратковременной неактивности Демона, Менеджер передаст ему назначенные задачи(вычисления продолжатся с того места, на котором они были прерваны). 
 - Демонам добавлен функционал Echo запросов, с помощью которых они 'сообщают' Менеджеру о своем статусе готовности выполнять задачи, а так же передают некоторые дополнительные сведения.  
 - Изменена фронтальная часть: добавлен функционал регистрации и аутентификации пользователей, добавлено отображение списка активных Демонов. Теперь, для изменения настроек Демона из браузера, необходимо ввести его адрес. Регистрация и аутентификация пользователей реализована с использованием JWT, но без использования т.н. 'рефреш'-токена. Также, не реализован выход пользователя(т.н. 'Logout').  
 - Взаимодействие между Менеджером и Демонами переведено на использование протокола gRPC.
 - Менеджер, а также каждый из Демонов является одновременно и gRPC-сервером и HTTP-сервером. Однако, и Менеджером и Демонами, для корректной работы gRPC-сервера и HTTP-сервера используются различные порты. В настройках Менеджера эти порты задаются отдельно, а в Демонах HTTP-сервер использует номер порта на единицу больше чем gRPC-сервер.  
 - Скорректированы некоторые функции и механики предыдущей версии, добавлены новые. Проведен небольшой рефакторинг кода, но без распределения кодовой базы по подкаталогам проекта.
 - В проект для каждого из компонет добавлен тесты.


<a name="solution-discriber"><h2>Общее описание решения</h2></a>

Распределенный вычислитель представляет собой несколько независимых взаимодействующих компонент:

- **Диспетчер** - служит для приёма от пользователей запросов на регистрацию/аутентификацию, на вычисление выражений и запросов результатов вычислений. 
Диспетчер помимо HTTP-интерфейса взаимодействия с Интернет браузером, взаимодействует с Хранилищем, в котором выполняется регистрация заданий на вычисления, а также получение информации о результатах расчетов.
- **Фронтальная часть(Frontend)** - представляет из себя HTML-страницу с js-кодом, посредством которой пользователи взаимодействуют с системой. *Вместо представленного фронтального решения допустимо использовать любую консоль HTTP-запросов, Curl и подобные инструменты, но это будет не так удобно.* 

    Интерфейс фронтальной части представляет из себя три вкладки: 
    - "Калькулятор" - для регистрации\аутентификации, отправки выражений на вычисления, 
    - "Список вычислений" - для просмотра списка активных Демонов-вычислителей и списка(последние сто) зарегистрированных в системе вычислительных задач от пользователей, 
    - "Настройки вычислителя" - для просмотра и изменения настроек Демонов.   
- **Хранилище** - промежуточное звено между Диспетчером и Менеджером, предназначенное для регистрации выражений на вычисления, хранения и обработки заданий на вычисление выражений, а также хранения информации о пользователях. Представляет собой сервер СУБД на базе PostgreSQL, развернутый в Docker.
- **Менеджер** - служит для управления вычислительными заданиями, распределением их(заданий) по Демонам-вычислителям. Помимо Хранилища, обменивается информацией с Демонами по gRPC. Имеет HTTP-интерфейс для получения списка активных Демонов и перечня зарегистрированных заданий от пользователей(HTTP-сервер и gRPC-сервер использут различные порты). 
- **Демон(вычислитель)** - служит для вычисления арифметических выражений, получаемых от Менеджера. Результаты вычислений возвращаются также Менеджеру, взаимодействие с которым организовано по gRPC. Имеет HTTP-интерфейс для просмотра и изменения настроек. Демон может стартовать на любом порту, но для работы gRPC и HTTP-серверов необходимы отдельные порты(HTTP-сервер использует номер порта на единицу больше чем gRPC-сервер).    


 
 <a name="solution-arch"><h2>Схема взаимодействия компонент системы</h2></a>

![Схема системы(взаимодействие компонент)](docs/images/g_scheme.jpg)




<a name="dispatcher"><h2>Диспетчер</h2></a>

Диспетчер служит для приёма от пользователей запросов на регистрацию/аутентификацию, на вычисление выражений и запросов результатов вычислений. 


Диспетчер обеспечивает обработку следующих запросов(HTTP API):
- запросы на регистрацию пользователей
- запросы аутентификации пользователей
- запросы от пользователей на вычисление новых выражений
- запросы на получение результатов вычислений 
  
Приём входящих клиентских запросов реализован через специально созданный интерфейс HTTP API. Запросы на вычисление выражений и получение результатов - используют JWT-токены пользователей, т.о. пользователю, чтобы отправить выражение на вычисление и получение результата необходимо аутентифицироваться. Также, для этих запросов возможно(и рекомендуется) включать кэширование. 

<a name="dispatcher-settings"><h3>Настройки Диспетчера</h3></a>
Пакет Диспетчер расположен в:  /cmd/dispatcher/main.go

Настройки параметров работы Диспетчера находятся в файле /cmd/dispatcher/dispatcher_config.json

- **expressionsEndpoint** - адрес ресурса для регистрации вычисления новых выражений и получения результатов 
- **userRegistrationEndpoint** - адрес ресурса регистрации новых пользователей
- **userLoginEndpoint** - адрес ресурса сервиса аутентификации пользователей
secretSignJwt - секретная подпись для генерации JWT-токенов
- **expirationTimeSecondsJwt** - интервал времени(в секундах), по истечении которого JWT-токен станет недействительным(считая от момента его генерации)
- **serverAddress** - адрес и порт, на котором работает сервис
- **maxLenghtRequestId** - максимальная длина идентификатора запроса на регистрацию(вычисление) нового выражения
- **usePrepareValidation** - флаг выполнения валидации входящих выражений. Если значение настройки - true, тогда выражения будут проходить предварительную валидацию(см. настройку prepareValidationRegex)
- **prepareValidationRegex** - строка регулярного выражения, используемая при валидации входящих выражений(см. usePrepareValidation). Настройка используется только если usePrepareValidation=true
- **maxLenghtExpression** - значение максимальной длины выражения(не может быть более 255)
- **useLocalRequestIdCache** - флаг использования локального кэша идентификаторов зарегистрированных на вычисления выражений. Используется при кэшировании запросов на добавление заданий на вычисление выражений. Если значение настройки - true, тогда перед обращением к Хранилищу, программа будет искать идентификатор соответствующей задачи в кэше. Если идентификатор задания будет найден в этом кэше, то обращения к Хранилищу выполняться не будет, клиенту будет возвращен результат из кэша. Если в кэше не будет найдена запись идентификатора, то программа выполнит запрос к Хранилищу и вернет соответствующий результат клиенту. При этом, если окажется, что задание ещё не зарегистрировано, то в локальный кэш будет добавлена соответствующая запись идентификатора для данного идентификатора запроса.
- **useLocalResultCache** - флаг использования локального кэша результатов вычислений. Если значение настройки true, тогда перед соответствующим обращением к Хранилищу, будет произведен поиск результата вычисления по идентификатору вычислительного задания в специальном кэше результатов. Если результат вычисления будет найден в этом кэше, то обращения к Хранилищу выполняться не будет, клиенту будет возвращен результат из кэша. Если в кэше не будет найдена запись результата, то программа выполнит запрос к Хранилищу и вернет соответствующий результат клиенту. При этом, если окажется, что вычисление уже завершилось, то в локальный кэш результатов будет добавлена соответствующая запись для данного вычислительного задания.
- **dbConnectionConfig** - стандартные параметры соединения с Хранилищем(в данной реализации с базой данных)



Пример настроечного файла:
```json
{
    "expressionsEndpoint": "/expressions",
    "userRegistrationEndpoint": "/api/v1/register",
    "userLoginEndpoint": "/api/v1/login",
    "secretSignJwt": "yandex",
    "expirationTimeSecondsJwt": 3600,
    "serverAddress": "127.0.0.1:8081",
    "maxLenghtRequestId": 50,
    "usePrepareValidation": true,
    "prepareValidationRegex": "^[0-9+\\-*/().^\\s]+$",
    "maxLenghtExpression": 255,
    "useLocalRequestIdCache": true,
    "useLocalResultCache": true,
    "dbConnectionConfig": {
        "host": "127.0.0.1",
        "port": 5432,
        "user": "admin",
        "password": "root",
        "dbname": "postgres"
    }
}
```

<a name="dispatcher-start"><h3>Запуск Диспетчера</h3></a>

```
go run cmd/dispatcher/main.go

```


<a name="dispatcher-query-reguser"><h3>Запрос регистрации пользователя</h3></a>
Обработка стандартная, с обычными проверками - логин не д.б. пустым, если пользователь с таким логином уже создан, то вернется ответ с кодом 400 и сообщением "User already exists".

Пример запроса и ответа:
```
curl -X POST \
  http://localhost:8081/api/v1/register \
  -H 'Content-Type: application/json' \
  -H 'X-Request-ID: lsphju8uygwhrjv6ywr' \
  -d '{"login": "Karlito", "password": "123"}'
```
```
HTTP/1.1 201 Created
Content-Type: application/json

{
  "message": "User registered successfully"
}
```
<a name="dispatcher-query-auth"><h3>Запрос аутентификации пользователя</h3></a>
Чтобы пользователь имел возможность отправлять новые задания на вычисление и получать их результаты, ему необходимо аутентифицироваться в системе и получить валидный JWT-токен. Для успешной аутентификации, пользователь должен передать правильный логин и пароль.

Полученный JWT-токен будет храниться в глобальных переменных js-кода HTML-страницы(фронтальная часть). Если JWT-токен станет невалидным("протухнет"), необходимо будет повторить запрос аутентификации.

Пример запроса и ответа:
```
curl -X POST \
  http://localhost:8081/api/v1/login \
  -H 'Content-Type: application/json' \
  -H 'X-Request-ID: lsphju8uygwhrjv6ywr' \
  -d '{"login": "Karlito", "password": "123"}'
```
```
HTTP/1.1 200 OK
Content-Type: application/json

{
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MTM3MDYyNDgsImlhdCI6MTcxMzcwMjY0OCwibmJmIjoxNzEzNzAyNjQ4LCJ1c2VySUQiOjEwfQ.kj6opoDYrGEH4jsTujAM5R7EcKZdooZ-PkE-WARU87U"
}
```


<a name="dispatcher-query-post"><h3>Запрос на вычисление выражений</h3></a>
Обработка включает несколько последовательных этапов:
- проверка наличия и валидности JWT-токена в заголовке
- проверка наличия идентификатора запроса в заголовке
- поиск в локальном кэше идентификатора задания ("task_id") по идентификатору запроса(опционально, см. настройку useLocalRequestIdCache)
- первичная валидация выражения(опциональная проверка на допустимые символы, без вычисления выражения и т.п.)
- регистрация выражения в Хранилище "как есть", т.е. в той форме(строкового представления), в каком оно было передано Диспетчеру
- обогащение локального кэша результатов для завершенных вычислений(опционально, см. настройку useLocalRequestIdCache)
- возврат клиенту идентификатора("task_id") задания на вычисление выражения

Запрос постановки на вычисление выражения должен представлять собой POST запрос вида:
```
curl -X POST -H "Content-Type: application/json" -H "X-Request-ID: идентификатор_запроса" -H "Authorization: jwt_токен" -d '{"expression": "ваше_выражение"}' http://адрес_диспетчера:порт_диспетчера/endpoint_диспетчера

```
Запрос возвращает идентификатор задания(успешный сценарий)
```
{"task_id":"идентификатор_задания"}
```

Пример запроса и ответа:
```
curl -X POST \
  http://localhost:8081/expressions \
  -H 'Content-Type: application/json' \
  -H 'X-Request-ID: zuphju9uygwhrjv7ywr' \
  -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MTIwMDA0NDMsImlhdCI6MTcxMTkxNDA0MywibmJmIjoxNzExOTE0MDQzLCJ1c2VySUQiOjEwfQ.7ws8tFBmvRvrt-PHAiPYAxTQv1BFbKEFOPnaa9HH7Lw' \
  -d '{
    "expression": "2+2"
}'

```
```
{"task_id":"8"}
```

<a name="dispatcher-query-get"><h3>Запрос результатов вычислений</h3></a>
Обработка включает несколько последовательных этапов:
- проверка наличия и валидности JWT-токена в заголовке
- получение из JWT-токена идентификатора пользователя
- поиск результата по идентификатору задания("task_id") в локальном кэше результатов вычислений(опционально, см. настройку useLocalResultCache)
- поиск результата идентификатору задания("task_id") и идентификатору пользователя в Хранилище
- обогащение локального кэша результатов для завершенных вычислений(опционально, см. настройку useLocalResultCache)
- возврат клиенту информации о ходе вычисления, или результата(если вычисление завершено)

Запрос информации о результате вычисления должен представлять собой GET запрос вида:
```
curl -H "Content-Type: application/json" -H "Authorization: jwt_токен" http://адрес_диспетчера:порт_диспетчера/endpoint_диспетчера?task_id=task_id
```
В ответе возвращается набор атрибутов задачи:
- expression - исходное выражение
- result - результат вычисления. Атрибут возвращается заполненным только если вычисления выражения завершено(т.е. если status = "Completed"). Если вычисление не завершено, то атрибут будет без значения.
- status - статус обработки
- is_finished - признак завершения обработки выражения
- is_wrong - признак ошибки при вычислении(например деление на нуль, недопустимый символ или операция, превышение допустимого времени на вычисление и т.п.)
- calc_duration - длительность обработки выражения в секундах
- comment - комментарий к выражению(заполняется при возникновении ошибок)

Атрибуты status и result возвращаются только при успешном выполнении запроса.

Пример запроса и ответа:
```
curl -X GET \
  'http://localhost:8081/expressions?task_id=129' \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MTIwMDA0NDMsImlhdCI6MTcxMTkxNDA0MywibmJmIjoxNzExOTE0MDQzLCJ1c2VySUQiOjEwfQ.7ws8tFBmvRvrt-PHAiPYAxTQv1BFbKEFOPnaa9HH7Lw'
```
```
{
    "expression": "10+2.5+15+15/3",
    "result": "0",
    "status": "error",
    "is_finished": true,
    "is_wrong": true,
    "calc_duration": 54,
    "comment": "The allowed calculation timeout has been exceeded"
}
```


<a name="storage"><h2>Хранилище</h2></a>
Хранилище предназначено для регистрации пользователей и выражений на вычисление, а так же хранения результатов(вычислений). Хранилище реализовано на базе СУБД PostgreSQL и состоит из трёх таблиц:

- **users** - таблица зарегистрированных пользователей 
- **reg_expr** - основная таблица регистрации заданий на вычисления от пользователей
- **calc_expr** - таблица Менеджера(т.н. "очередь" Менеджера) для управления вычислительными заданиями

Подробное описание самих таблиц можно изучить по скриптам их создания - см. файлы миграции в каталоге /migrations


<a name="storage-start"><h3>Настройка хранилища</h3></a>
В проекте использован Docker-образ сервера СУБД PostgreSQL - см.настройки файла docker-compose.yaml. Настоятельно рекомендую и вам использовать этот вариант. Так, в этом случае, при инициализации образа из контейнера, база данных будет автоматически создана и настроена(в т.ч. будут выполнены скрипты создания необходимых таблиц).

Инициализация и скачивание образов выполняется командой:
```
sudo docker compose up --build
```

*Если вы не используете docker, то вам необходимо создать в доступном вам экземпляре PostgreSQL новую базу данных и прописать актуальные параметры подключения к ней в настроечных файлах пакетов(Диспетчер и Менеджер). После этого, вам необходимо создать таблицы по скриптам из /migrations.*
 

 Для администрирования СУБД, рекомендую использовать любой известный вам инструмент, например pgadmin или плагин к вашей IDE и т.п. *В предыдущей версии распределенного вычислителя, я добавлял pgadmin в Docker-образ, но в этом решил его убрать, т.к. сам им не пользуюсь.* 

<a name="manager"><h2>Менеджер</h2></a>
Менеджер служит для управления вычислительными заданиями, распределением их(заданий) по Демонам-вычислителям.

В основном цикле обработки, Менеджер формирует т.н. "Очередь" - таблица calc_expr(Хранилища). Данная таблица формируется из задач получаемых Диспетчером и регистрируемых в таблице reg_expr. Задачи из Очереди распределяются по Демонам-вычислителям. Кроме этого, Менеджер возвращает завершенные задачи из Очереди в таблицу reg_expr. 

Механика взаимодействия с Демонами построена таким образом, что на стороне Менеджера ведётся и периодически корректируется, список активных Демонов(Демоны периодически посылают Менеджеру Echo-запрос), т.е. Демонов которые могут выполнять вычислительные задачи. Если какой-то Демон становится неактивным длительное время, то назначенные на него задачи будут переназначены. Важным моментом является и то, что Демоны после каждой итерации вычисления передают Менеджеру промежуточные результаты, и в случае переназначения Демона, вычисление будет возобновлено с места прерывания. 

Поскольку Демоны не имеют постоянной памяти(база данных и т.п.), то в случаях кратковременного выключения(Демонов) их очередь задач будет очищена. Для того, чтобы предотвратить возможные простои Демонов в таких ситупциях, Менеджер периодически отправляет Демонам назначенные на них задания.      

Также Менеджер следит за тем, чтобы в calc_expr небыло задач, обрабатываемых слишком долго. Такие задачи будут убраны из Очереди и завершены с ошибкой времени обработки.


<a name="manager-settings"><h3>Настройки Менеджера</h3></a>
Пакет Менеджер расположен в: /cmd/manager/main.go

Настройки параметров работы Менеджера представлены в файле /cmd/manager/manager_config.json

- **grpcServerAddress** - адрес и порт gRPC-сервера Менеджера
- **httpServerAddress** - адрес и порт HTTP-сервера Менеджера
- **endpointCalcs** - адрес ресурса для получения списка последних ста зарегистрированных заданий на вычисление
- **endpointDaemons** - адрес ресурса для получения списка активных Демонов
- **dbConnectionConfig** - стандартные параметры соединения с Хранилищем(в данной реализации с базой данных)
- **basicLoopDelaySeconds** - дополнительная задержка основного цикла
- **maxLenghtManagerQueue** - максимальная длина очереди задач Менеджера
- **maxDurationForTask** - время(в сек.) свыше которого задача на вычисление считается просроченной(т.е. это максимальное допустимый интервал время на вычисление выражения)
- **makeRPNInManager** - настройка, позволяющая получать RPN-выражения на стороне Менеджера
- **daemonInactivityTimeout** - время(в сек.), свыше которого, Демон считается неактивным
- **autoCheckIntervalOfActiveDaemons** - интервал(в сек.) автоматической корректировки активных Демонов
- **taskSendingToDaemonInterval** - Задержка(в сек.) отправки задач Демонам

Пример настроечного файла:
```
{
    "grpcServerAddress": "127.0.0.1:8091",
    "httpServerAddress": "127.0.0.1:8092",
    "endpointCalcs": "/calcmanager",
    "endpointDaemons": "/daemons",
    "dbConnectionConfig": {
        "host": "127.0.0.1",
        "port": 5432,
        "user": "admin",
        "password": "root",
        "dbname": "postgres"
    },
    "basicLoopDelaySeconds": 3,
    "maxLenghtManagerQueue": 30,
    "maxDurationForTask": 600,
    "makeRPNInManager": true,
    "daemonInactivityTimeout": 30,
    "autoCheckIntervalOfActiveDaemons": 10,
    "taskSendingToDaemonInterval": 1
}
```

<a name="manager-start"><h3>Запуск Менеджера</h3></a>

```
go run cmd/manager/main.go

```

<a name="manager-daemon"><h3>Взаимодействие с Демонами(вычислителями)</h3></a>
Для взаимодействия с Демонами, на стороне Менеджер развернут gRPC-сервер с сервисом CalcManager с методами Echo и Result. 
- Echo - метод, который вызывают Демоны для передачи сведений о своей активности(так же они передают свой адрес и размер очереди)
- Result - метод, который вызывают Демоны для передачи сведений о результатах(и промежуточных) результатах вычислений 

Для передачи Демонам заданий, Менеджер вызывает gRPC-сервер Демона, в частности его метод AddTask.

Описание proto-файла - см. файл grpc/proto_exchange/exchange.proto



<a name="manager-frontend"><h3>HTTP-интерфейс</h3></a>

Менеджер реализует HTTP-интерфейс и позволяет получить сведения об активных Демонах(настройка "endpointDaemons") и последних ста зарегистрированных заданиях на вычисление выражений от пользователей (настройка "endpointCalcs").

## Получение последних ста зарегистрированных заданий
```
curl http://адрес_менеджера:порт_менеджера/endpointCalcs
```
Пример запроса и ответа:
```
curl -X GET http://localhost:8092/calcmanager
```
```
[
    {
        "task_id": 3,
        "finish_date": "2024-04-21 20:23:53",
        "calc_duration": 87,
        "expression": "3+3+3+3+3",
        "comment": "",
        "status": "success",
        "result": 15,
        "is_wrong": false,
        "is_finished": true,
        "request_id": "lv9mabi5jiv9wfgq0wj",
        "reg_date": "2024-04-21T20:22:18.021585Z",
        "login": "Bill"
    },
    {
        "task_id": 2,
        "finish_date": "2024-04-21 20:23:06",
        "calc_duration": 53,
        "expression": "2+2+2",
        "comment": "",
        "status": "success",
        "result": 6,
        "is_wrong": false,
        "is_finished": true,
        "request_id": "lv9ma60n47v3uxyr7gt",
        "reg_date": "2024-04-21T20:22:04.56695Z",
        "login": "Bill"
    },
    {
        "task_id": 1,
        "finish_date": "2024-04-21 20:23:23",
        "calc_duration": 74,
        "expression": "1+1+2+2",
        "comment": "",
        "status": "success",
        "result": 6,
        "is_wrong": false,
        "is_finished": true,
        "request_id": "lv9ma1ovx5yy5dncy2d",
        "reg_date": "2024-04-21T20:21:59.129973Z",
        "login": "Bill"
    }
]
```

## Получение списка активных Демонов 
```
curl http://адрес_менеджера:порт_менеджера/endpointDaemons
```
Пример запроса и ответа:
```
curl -X GET http://localhost:8092/daemons
```
```
[
    {
        "address": "127.0.0.1:9000",
        "startTime": "2024-04-21T20:22:09+06:00",
        "capacity": 5,
        "queue": 0,
        "lastEchoTime": "2024-04-21T20:32:15+06:00",
        "delay": 0
    },
    {
        "address": "127.0.0.1:9002",
        "startTime": "2024-04-21T20:22:11+06:00",
        "capacity": 5,
        "queue": 0,
        "lastEchoTime": "2024-04-21T20:32:14+06:00",
        "delay": 1
    }
]
```

<a name="daemon"><h2>Демон(вычислитель)</h2></a>
Основная функция Демона - вычисление арифметических выражений полученных от Менеджера, и отправка обратно результатов(в т.ч. промежуточных). 

При начале работы Демон будет пытаться установить соединение с gRPC-сервером Менеджера и вызвать его метод Echo - т.о. Демон обозначает своё "присутствие", а Менеджер добавляет его в список активных Демонов, т.е. Демонов участвующих в распределении заданий на вычисление. При распределении заданий Менеджер вызывает метод AddTask сервиса CalcDaemon gRPC-сервера Демона и передаёт задание. При этом, Демон возвращает соответствующий статус Менеджеру(OK - "взял данную задачу сейчас или ранее", FULL - очередь полна). Таким образом формируется очередь Демона.

Почти всякая задача Демона, т.е. алгебраическое выражение, может быть разбита на отдельные подвыражения, которые возможно будет вычислить параллельно в отдельных горутинах. На каждом шаге вычисления таких редуцированных выражений, Демон предпринимает попытку отправить промежуточный результат Менеджеру(gRPC метод Result). Если вычисление выражение завершено, то после успешной передачи результата Менеджеру, Демон удаляет данную задачу из своей очереди.  


<a name="daemon-settings"><h3>Настройки Демона</h3></a>
Пакет Демон(вычислитель) расположен в: /cmd/calc_daemon/main.go

Настройки параметров работы Диспетчера представлены в файле /cmd/calc_daemon/calcdaemon_config.json

- **serverAddress** - адрес текущего экземпляра Демона(без порта)
- **defaultPort** - порт(по-умолчанию) на котором запущен текущий экземпляр Демона
- **configEndpoint** - адрес ресурса для получения и изменения настроек Демона
- **managerGRPCServer** - адрес и порт gRPC-сервера Менеджера
- **managerGRPCServerReconnectInterval** - интервал реконнектов к gRPC-серверу Менеджера(в сек.)
- **echoRepeatInterval** - интервал Echo-запросов к gRPC-серверу Менеджера(в сек.)
- **maxLenghtCalcQueue** - максимальное значение размера очереди заданий Демона
- **delayBasicLoop** - дополнительная задержка итерации главного цикла(в сек.)
- **delayAddingLoop** - дополнительная задержка итерации дополнительного цикла(в сек.)
- **maxGoroutinesInCalcProcess** - максимальное количество "параллельных" горутин для вычисления одного выражения
- **additionalDelayInCalcOperation** - дополнительная задержка каждой вычислительной бинарной подоперации(в сек.)


Пример настроечного файла:
```
{
    "serverAddress": "127.0.0.1",
    "defaultPort": "9000",
    "configEndpoint": "/config",
    "managerGRPCServer": "127.0.0.1:8091",
    "managerGRPCServerReconnectInterval": 3,
    "echoRepeatInterval": 3,
    "maxLenghtCalcQueue": 5,
    "delayBasicLoop": 1,
    "delayAddingLoop": 5,
    "maxGoroutinesInCalcProcess": 3,
    "additionalDelayInCalcOperation": 20
}
```

<a name="daemon-calc"><h3>Вычисление выражений</h3></a>
В файле(пакете) /internal/expression_processing/infix_to_postfix.go - представлена реализация преобразования инфиксных выражений в постфиксную форму, т.е. построение RPN-выражений. Данная библиотека тестировалась лишь на простых примерах.

- Реализована корректная обработка только простых арифметических **бинарных** операций: "+", "-", "*", "/", "^".
- Допустимо использование только простых круглых скобок
- Использование букв, специальных математических знаков и т.п.(кроме знаков поддерживаемых операций) - не поддерживается 


Для собственно вычисления алгебраического выражения используется следующий алгоритм:
1. В RPN строке ищутся тройки такие, что первые две позиции это числа, а третья позиция - знак операции.  
2. Все найденные тройки в предыдущем пункте вычисляются(эти вычисления распараллеливаются и вычисляются горутинами-агентами).
3. Строится новое редуцированное RPN выражение, где на места троек из п.2 вставляются соответствующие результаты и алгоритм повторяется. 
4. Алгоритм завершается, когда остаётся одно число. 
Алгоритм не сможет вычислить результат, если выражение, поданное на вход, будет некорректным(допустимы только корректные RPN)

Пример:
```
Инфиксная форма: 1 + (2+3) + (4 + 5) + (6 + 7) + 4*3/8
RPN expression: 1 2 3 + + 4 5 + + 6 7 + + 4 3 * 8 / +
тройки: (2 3 +), (4 5 +), (6 7 +), (4 3 *)

RPN expression: 1 5 + 9 + 13 + 12 8 / +
тройки: (1 5 +), (12 8 /)

RPN expression: 6 9 + 13 + 1.5 +
тройки: (6 9 +)

RPN expression: 15 13 + 1.5 +
тройки: (15 13 +)

RPN expression: 28 1.5 +
тройки: (28 1.5 +)

RPN expression: 29.5 - итоговый результат

```

```
Примеры корректных выражений:
1 + (2+3) + (4 + 5) + (6 + 7) + 4*3/8
10 + 2.5 + 15 + 15 / 3
1.1 * 4 - 2.2
2^3 - 1 + 4
4 * 2 + 14


Примеры некорректных выражений:
+ 1
+ 2 - 1
- ( - 1)
- ( - 2 ) * 3
5 !
```

## Схема поясняющая влияние настроек на процесс вычисления
![Схема поясняющая влияние настроек на процесс вычисления](docs/images/daemon_calc_scheme.jpg)




<a name="daemon-start"><h3>Запуск Демона</h3></a>
Демон реализует gRPC-сервер и HTTP-сервер и требует для своей работы два свободных соседних порта и, при старте Демона будет предпринята попытка запуска HTTP-сервера на порту с номером на единицу больше, чем у gRPC-сервера. Это важно и это нужно иметь в виду.


Запуск Демона на порту по-умолчанию 

По-умолчанию(из настроек) порт 9000 - на нем будет запущен gRPC-сервер, на порту 9001 будет запущен HTTP-сервер.
```
go run cmd/daemon/main.go
```
Запуск Демона на произвольном порту
```
go run main.go --port=номер_порта
```
Например:
```
go run main.go --port=9002
```
*При разработке, я обычно запускаю несколько Демонов на портах 9000, 9002, 9004 и т.д. Соответственно HTTP-серверы каждого из Демонов будут на портах 9001, 9003, 9005*

Вообще, количество одновременно работающих Демонов в системе не ограничено.


<a name="daemon-manager"><h3>Взаимодействие с Менеджером</h3></a>
Для взаимодействия Демонов с Менеджером, на стороне Менеджера развернут gRPC-сервер с сервисом CalcManager с методами Echo и Result. 
- Echo - метод, который вызывают Демоны для передачи сведений о своей активности(так же они передают свой адрес и размер очереди)
- Result - метод, который вызывают Демоны для передачи сведений о результатах(и промежуточных) результатах вычислений 

Каждый из Демонов реализует gRPC-сервер и сервис CalcDaemon с методом AddTask, который в свою очередь вызывает Менеджер для передачи заданий Демонам.

Описание proto-файла - см. файл grpc/proto_exchange/exchange.proto

<a name="daemon-frontend"><h3>HTTP-интерфейс</h3></a>
Каждый Демон реализует HTTP интерфейс для получения информации о текущих настройках, очереди и статистики, а также для изменения настроек.


## Получение текущих настроек, очереди заданий и статистики Демона
- Настройки - секция current_settings
- Текущая очередь - секция current_tasks
- Статистика - параметры верхнего уровня:
    - **start_time** - время запуска Демона
    - **uptime** - время работы Демона в секундах от запуска до настоящего момента
    - **qnt_current_tasks** - длина текущей очереди Демона
    - **qntProcessedTasks** - число обработанных Демоном заданий с момента его запуска

```
curl http://адрес_демона:порт_менеджера/configEndpoint
```
Пример запроса и ответа:
```
curl http://localhost:9001/config
```
```
{
    "start_time": "2024-04-21T21:21:19+06:00",
    "uptime": 557,
    "qnt_current_tasks": 2,
    "qntProcessedTasks": 2,
    "current_tasks": [
        {
            "record_id": 9,
            "task_id": 9,
            "expression": "1+1+1+1+1+2*2*2+1+1",
            "rpn_expression": "1 1 + 1 + 1 + 1 + 2 2 * 2 * + 1 + 1 + ",
            "is_finished": false,
            "is_wrong": false,
            "result": "0",
            "status": "running"
        },
        {
            "record_id": 10,
            "task_id": 10,
            "expression": "2+3+3+4+555-33*23232-4",
            "rpn_expression": "2 3 + 3 + 4 + 555 + 33 23232 * - 4 - ",
            "is_finished": false,
            "is_wrong": false,
            "result": "0",
            "status": "running"
        }
    ],
    "current_settings": {
        "serverAddress": "127.0.0.1",
        "defaultPort": "9000",
        "configEndpoint": "/config",
        "managerGRPCServer": "127.0.0.1:8091",
        "managerGRPCServerReconnectInterval": 3,
        "echoRepeatInterval": 3,
        "maxLenghtCalcQueue": 5,
        "delayBasicLoop": 1,
        "delayAddingLoop": 5,
        "maxGoroutinesInCalcProcess": 3,
        "additionalDelayInCalcOperation": 20
    }
}
```

## Изменение настроек Демона
Возможно изменение только следующих настроек:
- maxLenghtCalcQueue
- delayBasicLoop
- delayAddingLoop
- maxGoroutinesInCalcProcess
- additionalDelayInCalcOperation

```
curl -X POST -H "Content-Type: application/json" -d '{
  "settings": "{\"maxLenghtCalcQueue\":значение,\"delayBasicLoop\":значение,\"delayAddingLoop\":значение,\"maxGoroutinesInCalcProcess\":значение, \"additionalDelayInCalcOperation\":значение}"
}' http://адрес_демона:порт_демона/configEndpoint
```
Пример запроса и ответа:
```
curl -X POST -H "Content-Type: application/json" -d '{
  "settings": "{\"maxLenghtCalcQueue\":10,\"delayBasicLoop\":5,\"delayAddingLoop\":10,\"maxGoroutinesInCalcProcess\":10, \"additionalDelayInCalcOperation\":10}"
}' http://localhost:9001/config
```
```
В случае успеха, ответом будет код 200
```

<a name="frontend"><h2>Фронтальная часть(Frontend)</h2></a>
Для удобства пользователей разработана фронтальная часть - приложение страница HTML с js-кодом - см. fronend/calc_front.html


Приложение содержит три вкладки:
### Калькулятор
![Вкладка Калькулятор](docs/images/screen_calculator.jpg)

Здесь пользователь вводит нажимает кнопку"+", создается контейнер для ввода выражения. Пользователь вводит выражение, нажимает "Вычислить". Если запрос успешен, то поле ввода блокируетя, но активируется кнопка "Получить результат". Пользователь имеет возможность её нажимать, однако этого не требуется, т.к. на странице уже активирован соответствующий таймер для пуллинга(периодического выполнения запросов) результатов. После завершения вычисления, надписи под выражениям изменят цвет (зелёны - в случае успеха, красный - в случае ошибки). Результат, статус и само выражение - также отображаются. 
Пользователь может создать сколько угодно контейнеров и запускать их на вычисление. Для удобства, контейнеры можно удалять.


Также на вкладке имеются элементы для регистрации и аутентификации пользователя. В начале работы пользователю необходимо зарегистрироваться, т.е. ввести логин и пароль и нажать кнопку "Registration". Если регистрация прошла успешно, то пользователю необходимо аутентифицироваться - указать те же логин и пароль, что и при регистрации и нажать кнопку "Login". 

Важно: у неаутентифицированных пользователей не будут приниматься задания на вычисление, а так же не будут отображаться результаты. По-умолчанию, у текущего пользователя после регистрации в форме сохраняются логин и пароль, поэтому сложностей с повторным вводом быть не должно. 

Если срок действия JWT-токена истек, то необходимо аутентифицироваться заново(нажать кнопку "Login").

Механизма "logout", т.е. выхода не предусмотрено, т.к. этого не требуется по заданию. 

Для смены пользователя необходимо зайти под другим пользователем. В этом случае новый пользователь не увидит(не получит) результатов заданий, отправленных на вычисление предыдущим пользователем.




### Список вычислений
![Вкладка Список вычислений](docs/images/screen_calculator2.jpg)
На вкладке отображаются две таблицы:
- список активных Демонов. Нажимая кнопку "Выполнить запрос" - можно отслеживать состояние Демонов.
- сто последних запросов на вычисление от пользователей. Периодически нажимая кнопку "Выполнить запрос" - можно наблюдать как будут изменяться записи заданий.


### Настройки вычислителя
![Вкладка Настройки вычислителя](docs/images/screen_calculator3.jpg)
На данной вкладке отображаются настройки выбранного Демона-вычислителя. Для подключения к Демону, необходимо выяснить его адрес. Для этого подойдет список активных Демонов на вкладке "Список вычислений". Как уже несколько раз отмечено в этом документе, HTTP-интерфейс Демонов работает на номерах портов на единицу больше, чем gRPC-сервер соответствующего Демона - которые и указаны в таблице активных Демонов. 

При нажатии кнопки "Выполнить запрос" и успешном подключении к HTTP-интерфейсу Демона, на форме обновятся три контейнера и будут отображены текущие настройки этого Демона-вычислителя, будет отображены некоторые параметры статистики его работы с момента запуска, также отобразится его текущая очередь задач. 

Отображаемые параметры статистики Демона:
- **start_time** - время запуска Демона
- **uptime** - время работы Демона в секундах от запуска до настоящего момента
- **qnt_current_tasks** - длина текущей очереди Демона
- **qntProcessedTasks** - число обработанных Демоном заданий с момента его запуска


#### Текущие настройки
В настройках будут отображены текущие настройки Демона. Представление данных в самом просто JSON-формате. 
Данные настройки возможно изменить прямо в текущем окне контейнера. Для того, чтобы новые настройки были применены, необходимо нажать кнопку "Обновить настройки".

Более подробно по настройкам Демона - см. [Настройки Демона](#daemon-settings)



<a name="prepare_and_start"><h2>Подготовка и запуск проекта</h2></a>

0. Предполагается, что на вашем компьютере уже установлен GO 1.21.6(или выше) и Docker и Docker Compose современный релизов. 
Если у вас Windows,то необходимо также установить WSL.

1. Клонируйте проект на свой компьютер
```
git clone https://github.com/Federico-gangster/ya_lms_expression_calc_two.git
```
Если вы хотите клонировать проект в определенный каталог, вы можете добавить имя каталога после URL, как в следующем примере:
```
git clone https://github.com/Federico-gangster/ya_lms_expression_calc_two.git my_project
```

2. Установите зависимости
```
go mod tidy
```
3. Если у вас на компьютере установлена СУБД PostgreSQL, можно использовать её, а если нет, то рекомендуется использовать(т.е. установить) Docker.
Инициализация Хранилища см. также в [Настройка Хранилища](#storage-start)  

Инициализация Хранилища из Docker-образа:
```
sudo docker compose up --build
```

4. Поскольку Диспетчер, Менеджер и Демон(вычислитель) используют настроечные файлы, необходимо обеспечить, что для каждой из этих компонент в её области видимости доступен файл с настройками. Для обеспечения этого, следует запускать каждую из компонент из того каталога, где она расположена(вместе со своим файлом настроек), т.е.:

Запуск Диспетчера:
```
путь к проекту/ya_lms_expression_calc_two/cmd/dispatcher$ go run main.go
```
Запуск Менеджера
```
путь к проекту/ya_lms_expression_calc_two/cmd/manager$ go run main.go
```

Запуск Демона на порту по-умолчанию:
```
путь к проекту/ya_lms_expression_calc_two/cmd/calc_daemon$ go run main.go
```
Запуск Демона на выбранном порту:
```
путь к проекту/ya_lms_expression_calc_two/cmd/calc_daemon$ go run main.go --port=9002
```


Ситуация справедлива как для Windows, так и для Linux систем.

5. Если ваши настройки портов Диспетчера или Менеджера отличаются от моих, то для корректной работы Frondend, вам возможно потребуется изменить "захардкоженные" значения соответствующих переменных в файле calc_front.html

```
 // Глобальные переменные
var dispatcherAuthEndpoint = "http://localhost:8081/api/v1/register";
var dispatcherLoginEndpoint = "http://localhost:8081/api/v1/login";
var dispatcherExpressionEndpoint = "http://localhost:8081/expressions";
var ManagerServerAddress_endpointCalcs = "http://localhost:8092/calcmanager";
var ManagerServerAddress_endpointDaemons = "http://localhost:8092/daemons";
```

<a name="demo"><h2>Демо</h2></a>
В качестве демонстрации работы распределенного вычислителя, подготовлено несколько видеороликов - см. каталог /demo_video

На видео продемонстрирован запуск всех компонент, создание и регистрация пользователей, отправка выражений для вычисления, получение результатов(в т.ч. с ошибкой при делении на нуль). Также продемонстрировано перераспределение Менеджером задач между Демонами, управление настройками Демонов и работа со всеми вкладками фронтального приложения.